
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Astralis Optimizer – Offline 3D V3</title>
  <style>
    html, body { height: 100%; margin: 0; background: #040713; color: #e8ecf1; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { display: grid; grid-template-columns: 3fr 1fr; gap: 16px; height: 100%; padding: 12px; box-sizing: border-box; }
    .card { background: #0b1330; border: 1px solid #1a2753; border-radius: 14px; padding: 12px; display: flex; flex-direction: column; }
    .title { font-weight: 700; font-size: 16px; margin-bottom: 8px; }
    #viewport { flex: 1; min-height: 560px; border-radius: 12px; }
    .row { display: flex; align-items: center; gap: 8px; margin: 8px 0; flex-wrap: wrap; }
    .label { width: 160px; font-size: 12px; color: #9fb0d1; }
    input[type=range] { width: 180px; }
    select, button, input[type=number] { background: #0c1635; color: #e8ecf1; border: 1px solid #1a2753; border-radius: 8px; padding: 6px 8px; }
    button { cursor: pointer; }
    .note { font-size: 12px; color: #8ca0c7; }
    .legend { display: flex; gap: 16px; font-size: 12px; color: #9fb0d1; margin-top: 6px; flex-wrap: wrap; }
    .dot { width: 10px; height: 10px; border-radius: 10px; display: inline-block; margin-right: 6px; }
    @media (max-width: 1000px) { .wrap { grid-template-columns: 1fr; } }
    .pill { display:inline-block; padding:2px 6px; border-radius:999px; font-size:11px; }
    .ok { background:#0f3; color:#051; } .warn { background:#fd0; color:#520; } .bad { background:#f66; color:#400; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="title">Astralis Optimizer – Offline 3D V3</div>
      <canvas id="viewport"></canvas>
      <div class="legend">
        <div><span class="dot" style="background:#0f766e"></span>Ground</div>
        <div><span class="dot" style="background:#c9d1ff"></span>LEO</div>
        <div><span class="dot" style="background:#a7a7a7"></span>MEO</div>
        <div><span class="dot" style="background:#b579ff"></span>GEO</div>
        <div><span class="dot" style="background:#4aa8ff"></span>Optimized path</div>
        <div><span class="dot" style="background:#7fb0ff"></span>Baseline path</div>
        <div><span class="dot" style="background:#d05555"></span>Down link</div>
      </div>
      <div class="note">Drag to rotate. Scroll to zoom. Shaded globe and stars are procedural for full offline use.</div>
    </div>
    <div class="card">
      <div class="title">Controls</div>
      <div class="row"><span class="label">Source</span><select id="src"></select></div>
      <div class="row"><span class="label">Destination</span><select id="dst"></select></div>

      <div class="row"><span class="label">Demand</span><input id="demand" type="range" min="10" max="1400" step="10" value="400"><span id="vDemand">400 Mbps</span></div>
      <div class="row"><span class="label">Objective</span>
        <select id="objective">
          <option value="pareto">Pareto</option>
          <option value="latency">Min latency</option>
          <option value="cost">Min cost</option>
          <option value="energy">Min energy</option>
        </select>
      </div>
      <div class="row"><span class="label">Latency priority</span><input id="wLat" type="range" min="0" max="1" step="0.01" value="0.6"><span id="vLat">0.60</span></div>
      <div class="row"><span class="label">Cost priority</span><input id="wCost" type="range" min="0" max="1" step="0.01" value="0.25"><span id="vCost">0.25</span></div>
      <div class="row"><span class="label">Energy priority</span><input id="wEne" type="range" min="0" max="1" step="0.01" value="0.15"><span id="vEne">0.15</span></div>

      <div class="row"><span class="label">Weather</span><input id="weather" type="range" min="0" max="1" step="0.01" value="0.2"><span id="vWeather">0.20</span></div>
      <div class="row"><span class="label">Outages</span><input id="outages" type="checkbox" checked><span class="note">simulate failures</span></div>

      <div class="row"><span class="label">SLA max latency</span><input id="slaLat" type="number" value="120" min="10" max="1000"> ms</div>
      <div class="row"><span class="label">SLA max jitter</span><input id="slaJit" type="number" value="15" min="0" max="200"> ms</div>
      <div class="row"><span class="label">SLA max loss</span><input id="slaLoss" type="number" value="2" min="0" max="20"> %</div>
      <div class="row"><span class="label">Hard SLA constraint</span><input id="slaHard" type="checkbox" checked></div>

      <div class="row"><span class="label">FEC overhead</span><input id="fec" type="range" min="0" max="0.3" step="0.01" value="0.08"><span id="vFec">8%</span></div>
      <div class="row"><span class="label">Encryption overhead</span><input id="enc" type="range" min="0" max="0.3" step="0.01" value="0.05"><span id="vEnc">5%</span></div>
      <div class="row"><span class="label">Carbon price</span><input id="co2" type="number" value="0.12" step="0.01" min="0"> $/MJ</div>
      <div class="row"><span class="label">Trust-zone penalty</span><input id="tz" type="number" value="15" step="1" min="0"> ms</div>
      <div class="row"><span class="label">K-path diversity</span><input id="kPaths" type="number" value="2" min="1" max="3"></div>

      <div class="row"><button id="recompute">Recompute</button><button id="randomize">Randomize LEO</button></div>
      <div id="kpis" class="note" style="margin-top:6px"></div>
    </div>
  </div>

<script>
// Basic 3D math and projection
function deg2rad(d){ return d*Math.PI/180; }
function latLonToXYZ(lat, lon, r, alt){
  const phi = deg2rad(90 - lat), theta = deg2rad(lon + 180); const R = r + alt;
  return [ -R * Math.sin(phi) * Math.cos(theta), R * Math.cos(phi), R * Math.sin(phi) * Math.sin(theta) ];
}
function mulMatVec(m, v){ return [ m[0]*v[0]+m[1]*v[1]+m[2]*v[2], m[3]*v[0]+m[4]*v[1]+m[5]*v[2], m[6]*v[0]+m[7]*v[1]+m[8]*v[2] ]; }
function rotY(a){ const c=Math.cos(a), s=Math.sin(a); return [ c,0,-s, 0,1,0, s,0,c ]; }
function rotX(a){ const c=Math.cos(a), s=Math.sin(a); return [ 1,0,0, 0,c,-s, 0,s,c ]; }
function mulMat(a,b){ return [ a[0]*b[0]+a[1]*b[3]+a[2]*b[6], a[0]*b[1]+a[1]*b[4]+a[2]*b[7], a[0]*b[2]+a[1]*b[5]+a[2]*b[8], a[3]*b[0]+a[4]*b[3]+a[5]*b[6], a[3]*b[1]+a[4]*b[4]+a[5]*b[7], a[3]*b[2]+a[4]*b[5]+a[5]*b[8], a[6]*b[0]+a[7]*b[3]+a[8]*b[6], a[6]*b[1]+a[7]*b[4]+a[8]*b[7], a[6]*b[2]+a[7]*b[5]+a[8]*b[8] ]; }
function project([x,y,z], fov, w, h, zoom){ const d=fov*zoom; return [ (x/(z+d))*w/2 + w/2, (y/(z+d))*h/2 + h/2, z ]; }

// Canvas setup
const canvas = document.getElementById('viewport'), ctx = canvas.getContext('2d');
function resize(){ const w = Math.max(960, canvas.parentElement.clientWidth); const h = Math.max(560, canvas.parentElement.clientHeight); canvas.width = w; canvas.height = h; }
resize(); window.addEventListener('resize', resize);

// Scene constants
const R = 240;
const ALT = { Ground: 0, LEO: 60, MEO: 120, GEO: 180 };
const COLORS = { Ground: '#0f766e', LEO: '#c9d1ff', MEO: '#a7a7a7', GEO: '#b579ff' };

// Nodes and links with provider tags for trust-zone demo
const NODES = [
  { id: "g_hnl", name: "Honolulu GS", kind: "Ground", lat: 21.295, lon: -157.867, zone: "US" },
  { id: "g_sfo", name: "SF GS", kind: "Ground", lat: 37.775, lon: -122.419, zone: "US" },
  { id: "leo_1", name: "LEO-1", kind: "LEO", lat: 10, lon: -150, zone: "US" },
  { id: "leo_2", name: "LEO-2", kind: "LEO", lat: 25, lon: -140, zone: "US" },
  { id: "leo_3", name: "LEO-3", kind: "LEO", lat: -5, lon: -170, zone: "Intl" },
  { id: "meo_1", name: "MEO-1", kind: "MEO", lat: 0, lon: -160, zone: "Intl" },
  { id: "geo_1", name: "GEO-1", kind: "GEO", lat: 0, lon: -150, zone: "Intl" }
];
let LINKS = [
  { a:"g_hnl", b:"leo_1", latency_ms:8,  energy_j:2,   cost_usd:0.08, capacity_mbps:900 },
  { a:"leo_1", b:"leo_2", latency_ms:5,  energy_j:1,   cost_usd:0.03, capacity_mbps:1400 },
  { a:"leo_2", b:"g_sfo", latency_ms:10, energy_j:2,   cost_usd:0.06, capacity_mbps:900 },
  { a:"leo_1", b:"meo_1", latency_ms:20, energy_j:5,   cost_usd:0.10, capacity_mbps:600 },
  { a:"meo_1", b:"geo_1", latency_ms:60, energy_j:9,   cost_usd:0.20, capacity_mbps:300 },
  { a:"geo_1", b:"g_sfo", latency_ms:75, energy_j:9,   cost_usd:0.25, capacity_mbps:250 },
  { a:"leo_3", b:"leo_2", latency_ms:7,  energy_j:1.2, cost_usd:0.04, capacity_mbps:1100 },
  { a:"g_hnl", b:"leo_3", latency_ms:9,  energy_j:2.5, cost_usd:0.09, capacity_mbps:800 }
];

// Dynamic link state
const linkState = new Map();
for (const e of LINKS) linkState.set([e.a,e.b].sort().join('|'), { utilization: Math.random()*0.4, down:false });

// Network models
function queueDelayMs(baseLatencyMs, capacity, loadMbps){ const rho=Math.min(0.99, Math.max(0, loadMbps/capacity)); const extra=rho/Math.max(1e-6,1-rho); return baseLatencyMs*(1+0.5*extra); }
function effectiveEdge(e, demandMbps, weatherSeverity, outagesOn, tzPenaltyMs, fec, enc){
  const key=[e.a,e.b].sort().join('|'); const s=linkState.get(key) || {utilization:0, down:false};
  if (outagesOn && Math.random()<0.02) s.down = true; if (Math.random()<0.01) s.down = false; linkState.set(key, s);
  if (s.down) return { available:false };

  const aNode = NODES.find(n=>n.id===e.a), bNode = NODES.find(n=>n.id===e.b);
  const crossZone = aNode.zone !== bNode.zone ? tzPenaltyMs : 0;

  const weatherFactor = 1 + weatherSeverity * 1.5;
  const load = s.utilization * e.capacity_mbps + demandMbps*(1+fec+enc);
  const capacityOK = load <= e.capacity_mbps;

  // Base properties with overheads and weather
  let latency = queueDelayMs(e.latency_ms * weatherFactor, e.capacity_mbps, load);
  latency *= (1 + fec + enc); latency += crossZone;

  let energy  = e.energy_j * weatherFactor * (1 + enc*0.5); // encryption costs some power
  let cost    = e.cost_usd * (1 + fec); // FEC increases effective data size
  const loss  = Math.min(0.2, 0.02*weatherSeverity + Math.max(0, load - e.capacity_mbps*0.7)/e.capacity_mbps);

  // simple jitter model: proportional to utilization variance and weather
  const jitter = 0.1 * latency * (Math.min(1, load/e.capacity_mbps) * 0.6 + weatherSeverity*0.4);

  return { available: capacityOK, latency_ms: latency, energy_j: energy, cost_usd: cost, loss, jitter, eff_capacity: Math.max(0, e.capacity_mbps - load) };
}

// Scalarized constrained route with optional hard SLA filtering
function routeOnce(nodes, links, start, end, opts){
  const { demand, weather, outages, mode, weights, slaLat, slaJit, slaLoss, hard, tzPenalty, fec, enc, carbon } = opts;
  const idToIdx = new Map(nodes.map((n,i)=>[n.id,i])); const n = nodes.length;
  const adj = Array.from({length:n}, ()=>[]);
  const lat=[], ene=[], cst=[], jit=[], los=[], effs=[];

  for (const e of links){
    const eff = effectiveEdge(e, demand, weather, outages, tzPenalty, fec, enc);
    effs.push(eff);
    lat.push(eff.available ? eff.latency_ms : 1e9);
    ene.push(eff.available ? eff.energy_j   : 1e9);
    // convert energy to cost via carbon price as an externality
    const co2cost = eff.available ? (eff.energy_j/1000.0)*carbon : 0; // J -> kJ -> MJ approx
    cst.push(eff.available ? (eff.cost_usd + co2cost) : 1e9);
    jit.push(eff.available ? eff.jitter     : 1e9);
    los.push(eff.available ? eff.loss       : 1e9);
  }
  const norm = arr => { const f=arr.filter(v=>isFinite(v)&&v<1e8); const m=f.length?Math.max(...f):1; return arr.map(v=>v>=1e8?1e6:v/m); };
  const nl=norm(lat), ne=norm(ene), nc=norm(cst), nj=norm(jit), nL=norm(los);

  links.forEach((e,i)=>{
    const a=idToIdx.get(e.a), b=idToIdx.get(e.b);
    const eff = effs[i]; if (!eff.available) return;
    if (hard && (eff.latency_ms>slaLat || eff.jitter>slaJit || eff.loss*100>slaLoss)) return;
    let w;
    if (mode==='latency') w=nl[i];
    else if (mode==='cost') w=nc[i];
    else if (mode==='energy') w=ne[i];
    else w = weights.latency*nl[i] + weights.cost*nc[i] + weights.energy*ne[i] + 0.2*nj[i] + 0.2*nL[i];
    adj[a].push({to:b,w,i}); adj[b].push({to:a,w,i});
  });

  const s=idToIdx.get(start), t=idToIdx.get(end);
  const dist=Array(n).fill(Infinity), prev=Array(n).fill(null), vis=new Set();
  dist[s]=0;
  while(true){
    let u=-1,best=Infinity;
    for(let i=0;i<n;i++) if(!vis.has(i)&&dist[i]<best){best=dist[i];u=i;}
    if(u===-1||u===t) break;
    vis.add(u);
    for(const {to,w,i} of adj[u]){
      const nd=dist[u]+w;
      if(nd<dist[to]){ dist[to]=nd; prev[to]={node:u,edgeIndex:i}; }
    }
  }
  const pathIndices=[]; let cur=t;
  while(cur!==s && prev[cur]){ pathIndices.unshift(prev[cur].edgeIndex); cur=prev[cur].node; }

  let k={latency_ms:0,energy_j:0,cost_usd:0,min_capacity_mbps:Infinity,loss:0,jitter:0};
  for(const idx of pathIndices){
    const eff=effs[idx];
    k.latency_ms+=eff.latency_ms; k.energy_j+=eff.energy_j; k.cost_usd+=eff.cost_usd; k.min_capacity_mbps=Math.min(k.min_capacity_mbps, eff.eff_capacity); k.loss+=eff.loss; k.jitter+=eff.jitter;
  }
  return { pathIndices, kpis:k };
}

// K-path diversity by iteratively removing used edges
function kDisjointPaths(k, opts){
  const results=[]; let removed=new Set();
  for(let i=0;i<k;i++){
    const r = routeOnce(NODES, LINKS.filter((e,idx)=>!removed.has(idx)), opts.src, opts.dst, opts);
    results.push(r);
    // remove edges in last path
    r.pathIndices.forEach(idx=>removed.add(idx));
  }
  return results;
}

function baselineRoute(nodes, links, start, end){
  const idToIdx=new Map(nodes.map((n,i)=>[n.id,i])); const n=nodes.length, adj=Array.from({length:n},()=>[]);
  links.forEach((e,i)=>{ const a=idToIdx.get(e.a), b=idToIdx.get(e.b); adj[a].push({to:b,w:e.latency_ms,i}); adj[b].push({to:a,w:e.latency_ms,i}); });
  const s=idToIdx.get(start), t=idToIdx.get(end);
  const dist=Array(n).fill(Infinity), prev=Array(n).fill(null), vis=new Set(); dist[s]=0;
  while(true){ let u=-1,best=Infinity; for(let i=0;i<n;i++) if(!vis.has(i)&&dist[i]<best){best=dist[i];u=i;} if(u===-1||u===t) break; vis.add(u);
    for(const {to,w,i} of adj[u]){ const nd=dist[u]+w; if(nd<dist[to]){ dist[to]=nd; prev[to]={node:u,edgeIndex:i}; } } }
  const pathIndices=[]; let cur=t; while(cur!==s&&prev[cur]){ pathIndices.unshift(prev[cur].edgeIndex); cur=prev[cur].node; }
  let k={latency_ms:0,energy_j:0,cost_usd:0,min_capacity_mbps:Infinity,loss:0,jitter:0};
  for(const idx of pathIndices){ const e=LINKS[idx]; k.latency_ms+=e.latency_ms; k.energy_j+=e.energy_j; k.cost_usd+=e.cost_usd; k.min_capacity_mbps=Math.min(k.min_capacity_mbps,e.capacity_mbps); }
  return { pathIndices, kpis:k };
}

// Interaction
let yaw=0, pitch=0, zoom=1.0; let dragging=false, lx=0, ly=0;
canvas.addEventListener('mousedown', e=>{ dragging=true; lx=e.clientX; ly=e.clientY; });
window.addEventListener('mouseup', ()=> dragging=false);
window.addEventListener('mousemove', e=>{ if(!dragging) return; const dx=e.clientX-lx, dy=e.clientY-ly; lx=e.clientX; ly=e.clientY; yaw+=dx*0.005; pitch+=dy*0.005; pitch=Math.max(-1.4, Math.min(1.4, pitch)); });
canvas.addEventListener('wheel', e=>{ zoom *= (1 + Math.sign(e.deltaY)*0.1); zoom = Math.max(0.5, Math.min(2.5, zoom)); });

let packetPts=[], packetT=0;
function greatCircle(a, b, seg=64){ const pts=[]; for(let i=0;i<=seg;i++){ const t=i/seg; const x=a[0]*(1-t)+b[0]*t, y=a[1]*(1-t)+b[1]*t, z=a[2]*(1-t)+b[2]*t; const len=Math.hypot(x,y,z); const scale=1.15; pts.push([x/len*len*scale, y/len*len*scale, z/len*len*scale]); } return pts; }

function draw(){
  requestAnimationFrame(draw);
  const w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);
  // starfield
  ctx.fillStyle = '#040713'; ctx.fillRect(0,0,w,h);
  for(let i=0;i<120;i++){ const sx=(i*73)%w, sy=(i*199)%h; const alpha=(i%7)/10+0.2; ctx.fillStyle=`rgba(180,200,255,${alpha})`; ctx.fillRect(sx,sy,1,1); }

  const m = mulMat(rotY(yaw), rotX(pitch));
  const [cx, cy] = [w/2, h/2]; const r = R*(1/zoom);

  // shaded globe with light direction
  const lightDir = [0.9, 0.4, 0.2]; // fixed light
  const grd = ctx.createRadialGradient(cx-r*0.3, cy-r*0.3, r*0.2, cx, cy, r*1.2);
  grd.addColorStop(0, '#0c1a44'); grd.addColorStop(1, '#07102a');
  ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  // terminator glow
  ctx.strokeStyle = 'rgba(30,144,255,0.15)'; ctx.lineWidth = 8; ctx.beginPath(); ctx.arc(cx, cy, r*1.02, 0, Math.PI*2); ctx.stroke();

  // positions
  const positions = new Map();
  for(const n of NODES){
    const xyz = latLonToXYZ(n.lat, n.lon, R, ALT[n.kind]); const xyzr = mulMatVec(m, xyz);
    const [px,py,pz] = project(xyzr, 600, w, h, zoom); positions.set(n.id, {px,py,pz,kind:n.kind,name:n.name});
  }

  // routes
  const weights = { latency: parseFloat(wLat.value), cost: parseFloat(wCost.value), energy: parseFloat(wEne.value) };
  const opts = {
    src: document.getElementById('src').value,
    dst: document.getElementById('dst').value,
    demand: parseInt(document.getElementById('demand').value),
    weather: parseFloat(document.getElementById('weather').value),
    outages: document.getElementById('outages').checked,
    mode: document.getElementById('objective').value,
    weights,
    slaLat: parseFloat(document.getElementById('slaLat').value),
    slaJit: parseFloat(document.getElementById('slaJit').value),
    slaLoss: parseFloat(document.getElementById('slaLoss').value),
    hard: document.getElementById('slaHard').checked,
    tzPenalty: parseFloat(document.getElementById('tz').value),
    fec: parseFloat(document.getElementById('fec').value),
    enc: parseFloat(document.getElementById('enc').value),
    carbon: parseFloat(document.getElementById('co2').value)
  };
  const kPaths = Math.max(1, Math.min(3, parseInt(document.getElementById('kPaths').value)));
  const routes = kDisjointPaths(kPaths, opts);
  const base = baselineRoute(NODES, LINKS, opts.src, opts.dst);

  // draw links
  function drawLink(e, color, widthPx){
    const A = NODES.find(n=>n.id===e.a), B=NODES.find(n=>n.id===e.b);
    const vA = mulMatVec(m, latLonToXYZ(A.lat, A.lon, R, ALT[A.kind]));
    const vB = mulMatVec(m, latLonToXYZ(B.lat, B.lon, R, ALT[B.kind]));
    const arc = greatCircle(vA, vB, 48);
    ctx.beginPath();
    for(let i=0;i<arc.length;i++){ const [x,y,z]=arc[i]; const [px,py]=project([x,y,z],600,w,h,zoom); if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); }
    ctx.strokeStyle=color; ctx.lineWidth=widthPx; ctx.globalAlpha=0.9; ctx.stroke(); ctx.globalAlpha=1.0;
  }
  const baseSet = new Set(base.pathIndices.map(i=>i));
  LINKS.forEach((e, idx)=>{
    const st = linkState.get([e.a,e.b].sort().join('|')) || {down:false};
    let color = '#475a9a', wpx = 1.2;
    if (baseSet.has(idx)) { color = '#7fb0ff'; wpx = 2.0; }
    if (st.down) { color = '#d05555'; wpx = 2.2; }
    drawLink(e, color, wpx);
  });
  // optimized paths overlay
  const optColors = ['#4aa8ff', '#58d68d', '#f6c85f'];
  routes.forEach((r, i)=>{
    r.pathIndices.forEach(idx => drawLink(LINKS[idx], optColors[i%optColors.length], 2.8 - i*0.6));
  });

  // packet animates on first optimized path
  packetPts = [];
  if (routes[0] && routes[0].pathIndices.length){
    routes[0].pathIndices.forEach(i=>{
      const e=LINKS[i];
      const A=NODES.find(n=>n.id===e.a), B=NODES.find(n=>n.id===e.b);
      const vA = mulMatVec(m, latLonToXYZ(A.lat, A.lon, R, ALT[A.kind]));
      const vB = mulMatVec(m, latLonToXYZ(B.lat, B.lon, R, ALT[B.kind]));
      packetPts = packetPts.concat(greatCircle(vA, vB, 48));
    });
  }
  if (packetPts.length){ packetT = (packetT + 0.01) % 1.0; const idx = Math.floor(packetT*(packetPts.length-1));
    const [x,y,z]=packetPts[idx]; const [px,py]=project([x,y,z],600,w,h,zoom);
    ctx.fillStyle='#4aa8ff'; ctx.beginPath(); ctx.arc(px,py,3.5,0,Math.PI*2); ctx.fill();
  }

  // nodes on top
  for(const n of NODES){
    const p=positions.get(n.id);
    ctx.fillStyle = COLORS[n.kind]; ctx.beginPath(); ctx.arc(p.px, p.py, n.kind==='Ground'?4:3, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#cbd5ff'; ctx.font='11px system-ui, sans-serif'; ctx.fillText(n.name, p.px+6, p.py-6);
  }

  // KPIs aggregate across k paths: min latency, sum cost, availability approx
  const kAgg = routes.reduce((acc, r, i)=>{
    acc.latency_ms = i===0 ? r.kpis.latency_ms : Math.min(acc.latency_ms, r.kpis.latency_ms);
    acc.energy_j += r.kpis.energy_j; acc.cost_usd += r.kpis.cost_usd; acc.loss = Math.min(1, acc.loss + r.kpis.loss);
    acc.jitter += r.kpis.jitter; acc.min_capacity_mbps = Math.min(acc.min_capacity_mbps, r.kpis.min_capacity_mbps);
    return acc;
  }, { latency_ms: 1e9, energy_j:0, cost_usd:0, loss:0, jitter:0, min_capacity_mbps:Infinity });
  const b = base.kpis;
  const dl=(b.latency_ms - kAgg.latency_ms).toFixed(1);
  const dc=(b.cost_usd   - kAgg.cost_usd).toFixed(2);
  const de=(b.energy_j   - kAgg.energy_j).toFixed(1);
  const dj=(b.jitter     - kAgg.jitter).toFixed(1);
  function flag(v){ return v>0 ? '<span class="pill ok">better</span>' : v==0 ? '<span class="pill warn">same</span>' : '<span class="pill bad">worse</span>'; }
  document.getElementById('kpis').innerHTML = `
    <div><b>Optimized K-path vs Baseline</b></div>
    <div>Latency: ${kAgg.latency_ms.toFixed(1)} ms vs ${b.latency_ms.toFixed(1)} ms (Δ ${dl}) ${flag(b.latency_ms - kAgg.latency_ms)}</div>
    <div>Cost: $${kAgg.cost_usd.toFixed(2)}/GB vs $${b.cost_usd.toFixed(2)}/GB (Δ ${dc}) ${flag(b.cost_usd - kAgg.cost_usd)}</div>
    <div>Energy: ${kAgg.energy_j.toFixed(1)} J vs ${b.energy_j.toFixed(1)} J (Δ ${de}) ${flag(b.energy_j - kAgg.energy_j)}</div>
    <div>Jitter: ${kAgg.jitter.toFixed(1)} ms ${flag(-kAgg.jitter)}</div>
    <div>Bottleneck capacity: ${kAgg.min_capacity_mbps===Infinity?'n/a':kAgg.min_capacity_mbps.toFixed(0)} Mbps</div>
  `;
}

function syncLabels(){
  document.getElementById('vDemand').textContent = parseInt(document.getElementById('demand').value)+' Mbps';
  document.getElementById('vLat').textContent = Number(document.getElementById('wLat').value).toFixed(2);
  document.getElementById('vCost').textContent = Number(document.getElementById('wCost').value).toFixed(2);
  document.getElementById('vEne').textContent = Number(document.getElementById('wEne').value).toFixed(2);
  document.getElementById('vWeather').textContent = Number(document.getElementById('weather').value).toFixed(2);
  document.getElementById('vFec').textContent = Math.round(parseFloat(document.getElementById('fec').value)*100)+'%';
  document.getElementById('vEnc').textContent = Math.round(parseFloat(document.getElementById('enc').value)*100)+'%';
}

const srcSel=document.getElementById('src'), dstSel=document.getElementById('dst');
for(const n of NODES){
  const o1=document.createElement('option'); o1.value=n.id; o1.textContent=n.name; srcSel.appendChild(o1);
  const o2=document.createElement('option'); o2.value=n.id; o2.textContent=n.name; dstSel.appendChild(o2);
}
srcSel.value='g_hnl'; dstSel.value='g_sfo';

document.getElementById('recompute').addEventListener('click', syncLabels);
document.getElementById('randomize').addEventListener('click', ()=>{ for(const n of NODES) if(n.kind==='LEO'){ n.lat=-30+Math.random()*60; n.lon=-180+Math.random()*360; } });

['src','dst','demand','objective','wLat','wCost','wEne','weather','outages','slaLat','slaJit','slaLoss','slaHard','fec','enc','co2','tz','kPaths']
  .forEach(id => document.getElementById(id).addEventListener('input', syncLabels));

syncLabels();
draw();
</script>
</body>
</html>
